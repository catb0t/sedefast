#! sidef -WkP12

# how shiny is your Sidef?
class Luciu (case_name) {

  has reasons = []
  has Bool is_completed = false
  has Bool failed
  has Bool passed
  has Number count_failed = 0
  has Number count_passed = 0
  has Number count_cases  = 0

  method generate_is (test_like = true) {
    -> returned_func (*args) {
      var reason = Hash(:func => [__FUNC_NAME__, __METHOD_NAME__], :called_with => args.dclone, :test_like => test_like)
      var conjugate_test_like = (test_like ? "truth:  " : "falsity:")

      # no arguments = pass (?)
      given (args.len) {
        when (0) {
          reason += Hash(:result => :pass, :expl => "empty arguments")
          goto :passed
        }
        when (1) {
          reason += Hash(:caused_by => args[0].dclone, :expl => "#{test_like} expression")
          if (test_like == Bool(args[0])) {
            reason += Hash(:result => :pass)
            goto :passed
          } else {
            reason += Hash(:result => :pass)
            goto :failed
          }
        }
        default {
          args.combinations(2).each {
            var (first, second) = _...
            if (test_like != (first == second)) {
              var p = (test_like ? "" : "in")
              reason += Hash(:result => :fail, :caused_by => [first, second].dclone, :expl => "found #{p}equal arguments")
              goto :failed
            }
          }
          var p = (test_like ? "" : "in")
          reason += Hash(:result => :pass, :caused_by => args.dclone, :expl => "all #{p}equal arguments")
          goto :passed
        }
      }
      die "Test.generate_is.returned_func: how did we get here?"

      # TODO fix text alignment
      @:passed
        say "\t#{conjugate_test_like}\t'#{args.dump}'\t\tPASS"
        self.reasons.append(reason)
        return reason
      @:failed
        say "\t#{conjugate_test_like}\t'#{args.dump}'\t\tFAIL"
        # self.reasons += reason
        self.reasons.append(reason)
        return reason
    }
  }

  method _dies (block, regexes = [//, //], *args) {
    var reason = Hash(:func => __METHOD_NAME__, :called_with => Hash(:block => block, :regexes => regexes, :args => args.dclone))
    try {
      block.run(args...)
      reason += Hash(:result => :fail, :caused_by => [block, args.dclone], :expl => "no error caught")
      goto :no_exc
    } catch {
      |type, msg|
      if (type~~regexes[0] && msg~~regexes[1]) {
        reason += Hash(:result => :pass, :caused_by => [block, args.dclone], :expl => "expected error caught")
        goto :expected_exc;
      }
      reason += Hash(:result => :fail, :caused_by => [block, args.dclone], :expl => "unexpected error caught")
      goto :unexpected_exc
    }
    die "Test.dies: how did we get here?"

    @:expected_exc
      say "\tdies:\t\t'#{block.dump[^10]}...':\tPASS"
      self.reasons.append(reason)
      return reason
    @:unexpected_exc
      say "\tdies:\t\t'#{block.dump[^10]}...':\tFAIL (error mismatch)"
      self.reasons.append(reason)
      return reason
    @:no_exc
      say "\tdies:\t\t'#{block.dump[^10]}...':\tFAIL (nothing caught)"
      self.reasons.append(reason)
      return reason
  }

  method go (block) {
    say "  Case '#{self.case_name}'..."
    block.run(self.generate_is(true), self.generate_is(false), self.method("_dies"))
    var failed = self.reasons.grep{ _{:result} == :fail }
    var passed = self.reasons.grep{ _{:result} == :pass }

    self.is_completed = true
    self.failed = Bool(failed)
    self.passed = !Bool(failed)
    self.count_failed = failed.len
    self.count_passed = passed.len
    self.count_cases = self.reasons.len

    var res = (failed ? "FAIL" : "PASS")

    say "  Case '#{self.case_name}': #{res}"
    say "    failures -> #{failed.dump}" if (failed)

    self
  }
}

class Test < Luciu {}

# test-generator based on input / expectation specification
# this kind of thing is really useless in some contexts, let's see
class Meter {}

func main {
  var test_dir = Dir("tests")
  var run_tests = []

  for entry in (test_dir.open_r) {

    if ((entry =~ /^([^._].+\.st)$/)[0]) { # tests starting with _ or . are ignored
      |name|
      say "Testing cases in #{test_dir+name}..."
      var file_contents = (test_dir+File(name)->open_r.slurp)
      var output = eval( file_contents )
      run_tests.append(output)
      say "Tested #{name}"
    }
  }
  # say run_tests
  # this might be undone in the future, in which case we need to sum per-case / per-file
  run_tests.flatten!
  var passing_files = run_tests.grep{ .passed }.len
  var failing_files = run_tests.grep{ .failed }.len
  var passing_cases = run_tests.map{ .count_passed }.sum
  var failing_cases = run_tests.map{ .count_failed }.sum
  var total_cases = run_tests.map{ .count_cases }.sum
  say "\nSynopsis:"
  say "\tFiles: Tested: #{run_tests.len} | Passing: #{passing_files} | Failing: #{failing_files}"
  say "\tCases: Tested: #{total_cases} | Passing: #{passing_cases} | Failing: #{failing_cases}"
}

if (__FILE__ == __MAIN__) {
  main()
}
